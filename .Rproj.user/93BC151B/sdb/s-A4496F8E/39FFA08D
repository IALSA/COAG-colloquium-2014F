{
    "contents" : "cat(\"\\014\")\n#These first few lines run only when the file is run in RStudio, !!NOT when an Rmd/Rnw file calls it!!\nrm(list=ls(all=TRUE))  #Clear the variables from previous runs.\n\n############################\n## @knitr LoadPackages\nrequire(RODBC)\nrequire(grid)\nrequire(lattice)\nrequire(dplyr)\nrequire(ggplot2)\nrequire(gridExtra)\nrequire(lme4)\nrequire(reshape2)\n\n############################\n## @knitr DeclareGlobals\n# load common aesthetics definitions used in the reports\nsource(\"./Reports/LCMsequence/AesDefine.R\")\n# read back the definitions\n# aesDefs\n\n############################\n## @knitr LoadData\ndsL<-readRDS(\"./Data/Derived/dsL.rds\")\nsource(\"./Reports/LCMsequence/model-SPECIFICATION.R\")\n\n############################\n## @knitr defineData\n# numID<- 200 # highest id value (max = 9022)\nnumID <- 1000 # highest id value (max = 9022)\n### Define the data that will populate the model\nds<- dsL %>%  # chose conditions to apply in creating dataset for modeling\n  dplyr::filter(id < numID) %>%\n  dplyr::filter(year %in% c(2000:2011)) %>% # 1997:2011\n#   dplyr::filter(sample %in% c(1)) %>% # 0-Oversample; 1-Cross-Sectional\n  dplyr::filter(race %in% c(4)) %>% # 1-Black; 2-Hispanics; 3-Mixed; 4-White\n  dplyr::filter(byear %in% c(1980:1984)) %>% # birth year 1980:1984\n  dplyr::filter(ave(!is.na(attend), id, FUN = all)) %>% # only complete trajectories\n  dplyr::mutate( # compute new variables\n    age= year-byear, # definition of age to be used in the model    \n    timec=year-2000, # metric of time is rounds of NSLY97 in years, centered at 2000\n    timec2= timec^2, \n    timec3= timec^3,\n    #         timec= age-16, # metric of time is bilogical age in years, centered at 16\n    #         timec2= timec^2,\n    #         timec3= timec^3,# \n    cohort=byear-1980) %>% # age difference, years younger (unit - 1 cohort away)\n  dplyr::select( # assemble the dataset for modeling\n    id, race, byear,cohort, # Time Invariant variables\n    year,\n    age, attend, timec,timec2,timec3 )  # Time Variant variables\nhead(ds)\ntable(ds$byear) # the year of birth  - metric: YEAR \ntable(ds$age) # years past 16 -  metric: AGE\ntable(ds$year, ds$age) # YEAR by  AGE \nlength(unique(ds$id)) # total No. of respondents in dataset\nsum(!is.na(ds$attend)) # valid datapoints \nsum(is.na(ds$attend)) # NA in the dataset \nlength(unique(ds$timec))\n\n## FOR TESTING ###\n# flmer<- as.formula(call_m2_R2)\n# model <-lmer (flmer, data = ds, REML=FALSE,\n#               control=lmerControl(optCtrl=list(maxfun=20000)))\n# modelR<-model\n# \n# fnlme<- as.formula(call_m2_R2)\n# model<- nlme::gls(fnlme, data=ds,method = \"ML\")\n# modelF<-model\n###################\n\n\nallModels<- modelNamesLabels  # default definition of what models sequence contains\n# modelList1<- c(modelsR1, modelsFE)\n# modelList1<- c(modelsR2, modelsR3, modelsR4) \n# allModels <-  \"m0F\"\n# allModels <-  \"m1F\"\n# allModels <-  \"m0R1\"\n# allModels <-  \"mFa\"\n# allModels <-  \"mR1a\"\n# allModels <-   'm2_R2'\nfixedOnly <- modelsFE\n\nfor(i in allModels){\n  modelName<-  i  # should be \"i\" if not a specific model\n  message(\"Running model \", modelName, \" in model-ESTIMATION.R at \", Sys.time())\n  modelCall<- paste0(\"call_\",modelName)\n    f<- as.formula(modelCall)\n  isRandomModel <- !(modelName %in% fixedOnly)\n  if( isRandomModel ){\n    ########################################################################################\n    # if model is estimated by lmer() - with random effects\n    model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))\n    \n    ###########################\n    # @knitr solveModel_lmer\n    \n    ## mInfo ##\n    # model<- modelR\n    mInfo<-summary(model)$AICtab\n    mInfo[\"N\"]<- model@devcomp$dims[\"N\"] # number of datapoints, verify\n    mInfo[\"p\"]<- model@devcomp$dims[\"p\"] # number of estimated parameters, verify\n    mInfo[\"ids\"]<- (summary(model))$ngrps # number of units on level-2, here: individuals\n    # mInfo<- c(mInfo, \"modelName\"=modelName)\n    dsmInfo<-data.frame(mInfo)\n    dsmInfo<- plyr::rename(dsmInfo,replace= c(\"mInfo\"=modelName))\n    dsmInfo$Coefficient <- rownames(dsmInfo)\n    dsmInfo # model information \n    \n    ## dsFERE ##\n    # model<- modelR\n    FE<- fixef(model) # summary of fixed effects\n    FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value\n    mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects\n    mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,\"stddev\"))) \n    mRE$var<- mRE$sd^2\n    mRE<-mRE[c(\"var\",\"sd\")] # variances and standard deviations of random effects\n    mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE\n    mREcor<-  data.frame(attr(summary(model)$varcor$id,\"correlation\")) # corrleation matrix of RE\n    sigma<- sigma(model) # standard deviation of residual\n    \n    a<- data.frame(FEt)\n    a$Coefficient <- rownames(a)\n    a<- plyr::rename(a,replace= c(\"Std..Error\"=\"Std.Error\"))\n    rowCountBeforeJoin <- nrow(a)\n    \n    mFE<- (summary(model)$vcov@factors$correlation)\n    b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))\n    b$Coefficient <- rownames(b)\n    \n    dsRE <- mRE\n    dsRE <- plyr::rename(dsRE, replace=c(\"var\"=\"varRE\", \"sd\"=\"sdRE\"))\n    dsRE$Coefficient <- rownames(dsRE)\n    \n    dsRECov <- mREcov\n    ## - change here: if variables do not exist, create them anyway and populate with zeros\n    dsRECov <- plyr::rename(dsRECov, replace=c(\"X.Intercept.\"=\"intVarRE\", \"timec\"=\"timecVarRE\",\"timec2\"=\"timec2VarRE\",\"timec3\"=\"timec3VarRE\"),warn_missing = FALSE)\n    dsRECov$Coefficient <- rownames(dsRECov)\n    \n    dsRECor <- mREcor\n    ## - change here: if variables do not exist, create them anyway and populate with zeros\n    dsRECor <- plyr::rename(dsRECor, replace=c(\"X.Intercept.\"=\"intSDRE\", \"timec\"=\"timecSDRE\", \"timec2\"=\"timec2SDRE\", \"timec3\"=\"timec3SDRE\"),warn_missing = FALSE)\n    dsRECor$Coefficient <- rownames(dsRECor)\n    \n    dsFERE <- merge(x=a, y=b, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRE, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRECov, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRECor, by=\"Coefficient\", all=TRUE)\n    dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared\n    # dsFERE$modelName<- modelName\n    testit::assert(\"The join shouldn't add new records.\",  rowCountBeforeJoin==nrow(a))\n    testit::assert(\"The join shouldn't add new records.\",  nrow(dsFERE)==nrow(a))\n    testit::assert(\"The join shouldn't add new records.\",  nrow(dsFERE)==nrow(b))\n    dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared\n    # dsFERE$modelName<-modelName\n    head(dsFERE)\n    \n    ## dsp ## - deconstructing predictions\n    \n    # model<- modelR\n    dsp<- data.frame(getME(model,\"X\")) # get the model frame\n    dsp$id<-getME(model,\"flist\")$id # first level grouping factor, individual\n    dsp$y<-getME(model,\"y\") # observed response vector\n    dsp$yHat<- predict(model) # predicted values\n    dsp$resid<- lme4:::residuals.merMod(model)\n    head(dsp,13)\n    \n    # Deconstructed effects \n    # Fixed Effects \n    pullMainEffect <- function (timeName){\n      possibleNAEffect <- FE[timeName]\n      result <- ifelse( is.na(rep(possibleNAEffect,nrow(dsp))), 0,\n                        possibleNAEffect*dsp[,timeName]) \n      return(result)\n    }\n    \n    pullInteractionEffect <- function (timeName){\n      possibleNAEffect <- FE[paste0(timeName,\":cohort\")]\n      result <- ifelse( is.na(rep(possibleNAEffect,nrow(dsp))), 0,\n                        possibleNAEffect*dsp[,timeName]) \n      return(result)\n    }\n    \n    FE<- fixef(model)\n    # estimates of the fixed effects \n    #  gamma sub(0*) - pure time effects \n    # Intercept - gamma sub(00)\n    dsp$gamma00 <- FE[\"(Intercept)\"]\n    # Linear trend of time - gamma sub(01)\n    dsp$gamma01 <- pullMainEffect(\"timec\") \n    # Quadratic trend of time - gamma sub(02)\n    dsp$gamma02 <- pullMainEffect(\"timec2\") \n    # Cubic trend of time - gamma sub(03)\n    dsp$gamma03 <- pullMainEffect(\"timec3\") \n    #  gamma subs(1*) - effect of cohort(w1) on: \n    #  Intercept - gamma sub(01) \n    dsp$gamma10 <- FE[\"cohort\"]\n    # Linear trend of time - gamma sub(11)  \n    dsp$gamma11 <- pullInteractionEffect(\"timec\") \n    # Quadratic trend of time - gamma sub(12)\n    dsp$gamma12 <- pullInteractionEffect(\"timec2\") \n    # Cubic trend of time - gamma sub(13) \n    dsp$gamma13 <- pullInteractionEffect(\"timec3\") \n    \n    # Compute the mean trajectory, without the individual variability\n    # gamma sub(K*) - add more predictors here if expanding sequence\n    f.effects<- c(\"gamma00\",\"gamma01\",\"gamma02\",\"gamma03\",\n                  \"gamma10\",\"gamma11\",\"gamma12\",\"gamma13\")\n    dsp$yFE <- rowSums (dsp[,colnames(dsp) %in% f.effects],na.rm=TRUE)\n    head(dsp)\n    \n    RE<- lme4:::ranef.merMod(model)$id \n    RE$id=rownames(RE)\n    oldREnames<- c (\"(Intercept)\", \"timec\", \"timec2\", \"timec3\")\n    newREnames<- c(\"tau00sd\",\"tau11sd\", \"tau22sd\", \"tau33sd\")\n    for(i in 1:4)names(RE)[names(RE)==oldREnames[i]]=newREnames[i]\n    # head(RE)\n    # attach individual disturbances to dsp by id\n    dsp<- merge(dsp,RE, by=\"id\" )\n    # head(dsp)\n    \n    pullRandomEffect <- function (timeName,tauName){\n      variableMissing <- !(tauName %in% colnames(dsp))\n      if( variableMissing ) {\n        return( rep(0, times=nrow(dsp)) )\n      }\n      else {\n        possibleNAEffect <- dsp[,tauName]\n        result <- ifelse( is.na(possibleNAEffect), 0,\n                          possibleNAEffect*dsp[,timeName]) \n        return(result)\n      }\n    }\n    # pullRandomEffect(timeName=\"timec3\", tauName=\"tau33sd\")\n    # and produce predictions using the time effects \n    # note that tau00sd does not need transformation because it alwyas 1 \n    dsp$tau11sd <- pullRandomEffect(timeName=\"timec\", tauName=\"tau11sd\")\n    dsp$tau22sd <- pullRandomEffect(timeName=\"timec2\", tauName=\"tau22sd\")\n    dsp$tau33sd <- pullRandomEffect(timeName=\"timec3\", tauName=\"tau33sd\")\n    head(dsp)\n    \n    r.effects<- c(\"tau00sd\",\"tau11sd\",\"tau22sd\",\"tau33sd\")\n    dsp$yRE <- rowSums (dsp[,colnames(dsp) %in% r.effects],na.rm=TRUE)\n    head(dsp)\n    \n    # Check that the model solution deconstructed from fixed and random coefficient estimates (yFERE) matches the prediction produced by the built in function predict(model) or fitted(model).\n    d<- dsp %>%\n      dplyr::select(y,resid,yFE,yRE,yHat) %>%\n      dplyr::mutate(\n        yFERE=yFE+yRE, # predictions reconstructed manually\n        residFERE= y- yFERE,\n        residDif= resid- residFERE # residuals might slightly differ due to rounding\n      ) \n    head(d,10)\n    all.equal(dsp$yHat1, dsp$yFERE)\n    dsp$modelName<-modelName\n    \n    dsp<- data.frame(dsp)    \n  }\n  else{\n    ###########################################################################################\n    ############################\n    ## @knitr solveModel_gls\n    # if model is estimaged with nlme::gls - fixed effects, but with correlated residuals/uniqual variances\n    model<- nlme::gls(f, data=ds, method = \"ML\")\n    \n    ## mInfo ##\n    # model<- modelF\n    AIC<- AIC(model)\n    BIC<- BIC(model)\n    logLik<- summary(model)$logLik\n    deviance<- -2*logLik\n    df.resid<- NA\n    N<- summary(model)$dims$N\n    p<- summary(model)$dims$p\n    ids<- length(unique(ds$id))\n    df.resid<- N-p\n    \n    mInfo<- data.frame(\"AIC\" = AIC, \"BIC\" = BIC, \"logLik\" = logLik, \"deviance\"=deviance,\n                       \"df.resid\"=df.resid, \"N\"=N, \"p\"=p, \"ids\"=ids)\n    t<- t(mInfo)\n    rownames(t)<-colnames(mInfo)\n    dsmInfo<- data.frame(new=t)\n    colnames(dsmInfo)<- c(modelName)\n    dsmInfo$Coefficient <- rownames(dsmInfo)\n    dsmInfo\n    \n    ## dsFERE\n    # model<- modelF\n    FEt<- summary(model)$tTable\n    mFE<- (summary(model)$corBeta)\n    sigma<-model$sigma # std.error of scaled residuals \n        \n    a<- data.frame(FEt)\n    a$Coefficient <- rownames(a)\n    \n    b<- as.data.frame(mFE)\n    b$Coefficient <- rownames(b)\n        \n    #TODO: finsh you rarchitect how files are created and retrieve, \n    #  please don't keep using this hack that adds the `timec` row to an Anova table (intentionally) missing that variable\n    missingTime <- !(\"timec\" %in% a$Coefficient)\n    if( missingTime ) {\n      blankRowA <- a[1, ]\n      blankRowA[1, seq_len(ncol(a))] <- NA\n      blankRowA[1, \"Coefficient\"] <- \"timec\"\n      a <- plyr::rbind.fill(a, blankRowA)\n      rownames(a) <- a$Coefficient\n      \n      blankRowB <- b[1, ]\n      blankRowB[1, seq_len(ncol(b))] <- NA\n      blankRowB[1, \"Coefficient\"] <- \"timec\"\n      b <- plyr::rbind.fill(b, blankRowB)\n      b$timec <- NA\n      b[b$Coefficient==\"timec\", \"timec\"] <- 1\n      rownames(b) <- b$Coefficient\n      # b <- b[, c(\"(Intercept)\", \"timec\", \"Coefficient\")]\n    }\n        \n    rowCountBeforeJoin <- nrow(a)\n    \n    dsRE <- data.frame( row.names=rownames(b),VarRE=rep(0,nrow(b)))\n    dsRE$Coefficient <- rownames(dsRE)\n    \n    dsRECov <- data.frame( row.names=rownames(b),intVarRE=rep(0,nrow(b)))\n    dsRECov$Coefficient <- rownames(dsRECov)\n    \n    dsRECor <- data.frame( row.names=rownames(b),intSDRE=rep(0,nrow(b)))\n    dsRECor$Coefficient <- rownames(dsRECor)\n    \n    dsFERE <- merge(x=a, y=b, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRE, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRECov, by=\"Coefficient\", all=TRUE)\n    dsFERE <- merge(x=dsFERE, y=dsRECor, by=\"Coefficient\", all=TRUE)\n    dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared\n    # dsFERE$modelName<- modelName\n    testit::assert(\"The join shouldn't add new records.\",  rowCountBeforeJoin==nrow(a))\n    testit::assert(\"The join shouldn't add new records.\",  nrow(dsFERE)==nrow(a))\n    testit::assert(\"The join shouldn't add new records.\",  nrow(dsFERE)==nrow(b))\n    \n    dsFERE<- dsFERE\n    head(dsFERE)     \n    \n    ## dsp ## - deconstructing predictions\n    # modelF<-model\n    # model<-modelF\n    #TODO: my guess is it's better/safer to start with a (trimmed/narrowed ds), then merge the dsp variables of yHad and residual\n    # dsNarrow <- ds[, c(\"id\", \"timec\")]\n    \n    dsp<-(lm(f, data=ds))$model\n    dsp$id<- ds$id\n    dsp$timec <- ds$timec\n    dsp$yHat<- fitted(model)\n    dsp$resid<- residuals(model)\n    head(dsp,13)    \n    \n    pullMainEffect <- function (timeName){\n      possibleNAEffect <- FE[timeName]\n      result <- ifelse( is.na(rep(possibleNAEffect,nrow(dsp))), 0,\n                        possibleNAEffect*dsp[,timeName]) \n      return(result)\n    }\n    \n    pullInteractionEffect <- function (timeName){\n      possibleNAEffect <- FE[paste0(timeName,\":cohort\")]\n      result <- ifelse( is.na(rep(possibleNAEffect,nrow(dsp))), 0,\n                        possibleNAEffect*dsp[,timeName]) \n      return(result)\n    }\n    \n    FE<- summary(model)$coefficients\n    # estimates of the fixed effects \n    #  gamma sub(0*) - pure time effects \n    # Intercept - gamma sub(00)\n    dsp$gamma00 <- FE[\"(Intercept)\"]\n    # Linear trend of time - gamma sub(01)\n    dsp$gamma01 <- pullMainEffect(\"timec\") \n    # Quadratic trend of time - gamma sub(02)\n    dsp$gamma02 <- pullMainEffect(\"timec2\") \n    # Cubic trend of time - gamma sub(03)\n    dsp$gamma03 <- pullMainEffect(\"timec3\") \n    #  gamma subs(1*) - effect of cohort(w1) on: \n    #  Intercept - gamma sub(01) \n    dsp$gamma10 <- FE[\"cohort\"]\n    # Linear trend of time - gamma sub(11)  \n    dsp$gamma11 <- pullInteractionEffect(\"timec\") \n    # Quadratic trend of time - gamma sub(12)\n    dsp$gamma12 <- pullInteractionEffect(\"timec2\") \n    # Cubic trend of time - gamma sub(13) \n    dsp$gamma13 <- pullInteractionEffect(\"timec3\") \n    \n    \n    # Compute the mean trajectory, without the individual variability\n    # gamma sub(K*) - add more predictors here if expanding sequence\n    f.effects<- c(\"gamma00\",\"gamma01\",\"gamma02\",\"gamma03\",\n                  \"gamma10\",\"gamma11\",\"gamma12\",\"gamma13\")\n    dsp$yFE <- rowSums (dsp[,colnames(dsp) %in% f.effects],na.rm=TRUE)\n    head(dsp)\n    \n    \n    \n    pullRandomEffect <- function (timeName,tauName){\n      variableMissing <- !(tauName %in% colnames(dsp))\n      if( variableMissing ) {\n        return( rep(0, times=nrow(dsp)) )\n      }\n      else {\n        possibleNAEffect <- dsp[,tauName]\n        result <- ifelse( is.na(possibleNAEffect), 0,\n                          possibleNAEffect*dsp[,timeName]) \n        return(result)\n      }\n    }\n    # pullRandomEffect(timeName=\"timec3\", tauName=\"tau33sd\")\n    \n    # and produce predictions using the time effects \n    # note that tau00sd stays here just to create the column\n    dsp$tau00sd <- 0\n    dsp$tau11sd <- pullRandomEffect(timeName=\"timec\", tauName=\"tau11sd\")\n    dsp$tau22sd <- pullRandomEffect(timeName=\"timec2\", tauName=\"tau22sd\")\n    dsp$tau33sd <- pullRandomEffect(timeName=\"timec3\", tauName=\"tau33sd\")\n  } # close else\n  \n  #TODO: fix this hack\n  missingTimeInDsp <- !(\"timec\" %in% colnames(dsp))\n  if( missingTimeInDsp ) {\n#     dsTimeOnly <- ds[]\n    #TODO: the 'timec' variable needs to be merged into the dsp dataset, using the ds dataset.\n    #  However, there's not a good set of variables to match on.\n    dsp$timec <- NA_real_\n  }\n  head(dsp)\n  \n  ###########################################################################################\n  ## @knitr saveModelResults\n  modelName\n  pathdsmInfo <- file.path(\"./Reports/LCMsequence/models/datasets\",paste0(modelName,\"_mInfo.rds\"))\n  pathdsFERE  <- file.path(\"./Reports/LCMsequence/models/datasets\",paste0(modelName,\"_FERE.rds\"))\n  pathdsp     <- file.path(\"./Reports/LCMsequence/models/datasets\",paste0(modelName,\"_dsp.rds\"))\n  \n  saveRDS(object=dsmInfo, file=pathdsmInfo, compress=\"xz\")\n  saveRDS(object=dsFERE, file=pathdsFERE, compress=\"xz\")\n  saveRDS(object=dsp, file=pathdsp, compress=\"xz\")\n\n} # end of the for loop\n",
    "created" : 1417117742075.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3624446116",
    "id" : "39FFA08D",
    "lastKnownWriteTime" : 1417121197,
    "path" : "~/GitHub/COAG-colloquium-2014F/Reports/LCMsequence/model-ESTIMATION.R",
    "project_path" : "Reports/LCMsequence/model-ESTIMATION.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}