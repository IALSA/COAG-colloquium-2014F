#These first few lines run only when the file is run in RStudio, !!NOT when an Rmd/Rnw file calls it!!
rm(list=ls(all=TRUE))  #Clear the variables from previous runs.
############################
## @knitr LoadPackages
require(RODBC)
require(grid)
require(lattice)
require(dplyr)
require(ggplot2)
require(gridExtra)
require(lme4)
require(reshape2)
############################
## @knitr DeclareGlobals
# load common aesthetics definitions used in the reports
source("./Reports/LCMsequence/AesDefine.R")
# read back the definitions
# aesDefs
############################
## @knitr LoadData
dsL<-readRDS("./Data/Derived/dsL.rds")
source("./Reports/LCMsequence/model-SPECIFICATION.R")
############################
## @knitr defineData
# numID<- 200 # highest id value (max = 9022)
numID <- 1000 # highest id value (max = 9022)
### Define the data that will populate the model
ds<- dsL %>%  # chose conditions to apply in creating dataset for modeling
dplyr::filter(id < numID) %>%
dplyr::filter(year %in% c(2000:2011)) %>% # 1997:2011
#   dplyr::filter(sample %in% c(1)) %>% # 0-Oversample; 1-Cross-Sectional
dplyr::filter(race %in% c(4)) %>% # 1-Black; 2-Hispanics; 3-Mixed; 4-White
dplyr::filter(byear %in% c(1980:1984)) %>% # birth year 1980:1984
dplyr::filter(ave(!is.na(attend), id, FUN = all)) %>% # only complete trajectories
dplyr::mutate( # compute new variables
age= year-byear, # definition of age to be used in the model
timec=year-2000, # metric of time is rounds of NSLY97 in years, centered at 2000
timec2= timec^2,
timec3= timec^3,
#         timec= age-16, # metric of time is bilogical age in years, centered at 16
#         timec2= timec^2,
#         timec3= timec^3,#
cohort=byear-1980) %>% # age difference, years younger (unit - 1 cohort away)
dplyr::select( # assemble the dataset for modeling
id, race, byear,cohort, # Time Invariant variables
year,
age, attend, timec,timec2,timec3 )  # Time Variant variables
head(ds)
table(ds$byear) # the year of birth  - metric: YEAR
table(ds$age) # years past 16 -  metric: AGE
table(ds$year, ds$age) # YEAR by  AGE
length(unique(ds$id)) # total No. of respondents in dataset
sum(!is.na(ds$attend)) # valid datapoints
sum(is.na(ds$attend)) # NA in the dataset
length(unique(ds$timec))
## FOR TESTING ###
# flmer<- as.formula(call_m2_R2)
# model <-lmer (flmer, data = ds, REML=FALSE,
#               control=lmerControl(optCtrl=list(maxfun=20000)))
# modelR<-model
#
# fnlme<- as.formula(call_m2_R2)
# model<- nlme::gls(fnlme, data=ds,method = "ML")
# modelF<-model
###################
allModels<- modelNamesLabels  # default definition of what models sequence contains
# modelList1<- c(modelsR1, modelsFE)
# modelList1<- c(modelsR2, modelsR3, modelsR4)
# allModels <-  "m0F"
# allModels <-  "m1F"
# allModels <-  "m0R1"
# allModels <-  "mFa"
# allModels <-  "mR1a"
# allModels <-   'm2_R2'
fixedOnly <- modelsFE
cat("\014")
#These first few lines run only when the file is run in RStudio, !!NOT when an Rmd/Rnw file calls it!!
rm(list=ls(all=TRUE))  #Clear the variables from previous runs.
############################
## @knitr LoadPackages
require(RODBC)
require(grid)
require(lattice)
require(dplyr)
require(ggplot2)
require(gridExtra)
require(lme4)
require(reshape2)
############################
## @knitr DeclareGlobals
# load common aesthetics definitions used in the reports
source("./Reports/LCMsequence/AesDefine.R")
# read back the definitions
# aesDefs
############################
## @knitr LoadData
dsL<-readRDS("./Data/Derived/dsL.rds")
source("./Reports/LCMsequence/model-SPECIFY.R")
############################
## @knitr defineData
# numID<- 200 # highest id value (max = 9022)
numID <- 1000 # highest id value (max = 9022)
### Define the data that will populate the model
ds<- dsL %>%  # chose conditions to apply in creating dataset for modeling
dplyr::filter(id < numID) %>%
dplyr::filter(year %in% c(2000:2011)) %>% # 1997:2011
#   dplyr::filter(sample %in% c(1)) %>% # 0-Oversample; 1-Cross-Sectional
dplyr::filter(race %in% c(4)) %>% # 1-Black; 2-Hispanics; 3-Mixed; 4-White
dplyr::filter(byear %in% c(1980:1984)) %>% # birth year 1980:1984
dplyr::filter(ave(!is.na(attend), id, FUN = all)) %>% # only complete trajectories
dplyr::mutate( # compute new variables
age= year-byear, # definition of age to be used in the model
timec=year-2000, # metric of time is rounds of NSLY97 in years, centered at 2000
timec2= timec^2,
timec3= timec^3,
#         timec= age-16, # metric of time is bilogical age in years, centered at 16
#         timec2= timec^2,
#         timec3= timec^3,#
cohort=byear-1980) %>% # age difference, years younger (unit - 1 cohort away)
dplyr::select( # assemble the dataset for modeling
id, race, byear,cohort, # Time Invariant variables
year,
age, attend, timec,timec2,timec3 )  # Time Variant variables
head(ds)
table(ds$byear) # the year of birth  - metric: YEAR
table(ds$age) # years past 16 -  metric: AGE
table(ds$year, ds$age) # YEAR by  AGE
length(unique(ds$id)) # total No. of respondents in dataset
sum(!is.na(ds$attend)) # valid datapoints
sum(is.na(ds$attend)) # NA in the dataset
length(unique(ds$timec))
## FOR TESTING ###
# flmer<- as.formula(call_m2_R2)
# model <-lmer (flmer, data = ds, REML=FALSE,
#               control=lmerControl(optCtrl=list(maxfun=20000)))
# modelR<-model
#
# fnlme<- as.formula(call_m2_R2)
# model<- nlme::gls(fnlme, data=ds,method = "ML")
# modelF<-model
###################
allModels<- modelNamesLabels  # default definition of what models sequence contains
# modelList1<- c(modelsR1, modelsFE)
# modelList1<- c(modelsR2, modelsR3, modelsR4)
# allModels <-  "m0F"
# allModels <-  "m1F"
# allModels <-  "m0R1"
# allModels <-  "mFa"
# allModels <-  "mR1a"
# allModels <-   'm2_R2'
fixedOnly <- modelsFE
modelName<-  "m0_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
model
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
dsp<- data.frame(getME(model,"X")) # get the model frame
dsp
View(dsp)
modelName<-  "m1_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsp)
call_m0_R1 <- "attend ~ 1 + (1 | id) "
modelName<-  "m1_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsL)
View(dsp)
modelName<-  "m0_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsp)
getME(model,"X")
str(model)
getME(model,"Intercetp.X")
BuildLine("m2_R2")
# rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run. This is not called by knitr, because it's above the first chunk.
require(ggplot2)
require(dplyr)
require(reshape2)
BuildLine <- function( modelName, baseSize=11 ) {
modelName<- "m1_R1"
# Traditional reading in the files
pathdsp  <- file.path("./Reports/LCMsequence/models/datasets", paste0(modelName,"_dsp.rds"))
dsp <- readRDS(pathdsp)
###############################################
### graph of prediction
# bgColour<-gray(.95)   # background color
indLineSz <-.08        # individual line size
#   indLineSz <-.5        # individual line size
indLineAl <-.06        # individual line alpha
#   indLineAl <-1        # individual line alpha
themeLine <- ggplot2::theme_bw(base_size=baseSize) +
ggplot2::theme(title=ggplot2::element_text(colour="gray20",size = 12)) +
ggplot2::theme(axis.text=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(axis.title=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(panel.border = ggplot2::element_rect(colour="gray80")) +
ggplot2::theme(axis.ticks.length = grid::unit(0, "cm")) +
ggplot2::theme(text = element_text(size =20)) #+
# ggplot2::theme(panel.background=element_rect(fill=bgColour,colour=NA)) +
# ggplot2::theme(legend.position=c(.95,.90),legend.direction="vertical") +
# ggplot2::theme(legend.background = element_rect(fill=NA)) +
# ggplot2::theme(legend.text = element_text(size = 15),legend.title.align =(-3.3))# +
# ggplot2::theme(panel.grid = element_line(linetype = 1,size=rel(3)))
ds<- dsp %>% dplyr::filter(id %in% c(1:9022))
# ds<- dsp
# head(ds)
p<- ggplot2::ggplot(ds, aes(x=timec, y=attend, group=id))
# geoms
p <- p + geom_line(aes(x=timec,y=yHat),colour="red",alpha=indLineAl,size=indLineSz, na.rm=T)
p <- p + geom_line(aes(y=yFE), fill=NA, na.rm=T)
# scales & coordinates
p <- p + scale_x_continuous(breaks=c(0:11))
p <- p + scale_y_continuous(breaks=seq(0, 8, 1))
p <- p + coord_cartesian(xlim=c(-.5, 11.5), ylim=c(.5, 8.5))
# themes, guide, and annotations
p <- p + themeLine
p <- p + labs(title="How often have you attended a worship service?", x="Years Since 2000", y="Church Attendance")
#   ggsave(filename="./Models/LCM/graphs/text/m7F_2.png", plot=p, width =5 , height =4) # uncomment to produce graph in lines below the function
return( p )
}
BuildLine("m2_R2")
BuildLine("m1_R1")
BuildLine("m2_R2")
BuildLine("m1_R1")
BuildLine("m2_R2")
BuildLine("m0_R1")
# rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run. This is not called by knitr, because it's above the first chunk.
require(ggplot2)
require(dplyr)
require(reshape2)
BuildLine <- function( modelName, baseSize=11 ) {
#   modelName<- "m1_R1"
# Traditional reading in the files
pathdsp  <- file.path("./Reports/LCMsequence/models/datasets", paste0(modelName,"_dsp.rds"))
dsp <- readRDS(pathdsp)
###############################################
### graph of prediction
# bgColour<-gray(.95)   # background color
indLineSz <-.08        # individual line size
#   indLineSz <-.5        # individual line size
indLineAl <-.06        # individual line alpha
#   indLineAl <-1        # individual line alpha
themeLine <- ggplot2::theme_bw(base_size=baseSize) +
ggplot2::theme(title=ggplot2::element_text(colour="gray20",size = 12)) +
ggplot2::theme(axis.text=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(axis.title=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(panel.border = ggplot2::element_rect(colour="gray80")) +
ggplot2::theme(axis.ticks.length = grid::unit(0, "cm")) +
ggplot2::theme(text = element_text(size =20)) #+
# ggplot2::theme(panel.background=element_rect(fill=bgColour,colour=NA)) +
# ggplot2::theme(legend.position=c(.95,.90),legend.direction="vertical") +
# ggplot2::theme(legend.background = element_rect(fill=NA)) +
# ggplot2::theme(legend.text = element_text(size = 15),legend.title.align =(-3.3))# +
# ggplot2::theme(panel.grid = element_line(linetype = 1,size=rel(3)))
ds<- dsp %>% dplyr::filter(id %in% c(1:9022))
# ds<- dsp
# head(ds)
p<- ggplot2::ggplot(ds, aes(x=timec, y=attend, group=id))
# geoms
p <- p + geom_line(aes(x=timec,y=yHat),colour="red",alpha=indLineAl,size=indLineSz, na.rm=T)
p <- p + geom_line(aes(y=yFE), fill=NA, na.rm=T)
# scales & coordinates
p <- p + scale_x_continuous(breaks=c(0:11))
p <- p + scale_y_continuous(breaks=seq(0, 8, 1))
p <- p + coord_cartesian(xlim=c(-.5, 11.5), ylim=c(.5, 8.5))
# themes, guide, and annotations
p <- p + themeLine
p <- p + labs(title="How often have you attended a worship service?", x="Years Since 2000", y="Church Attendance")
#   ggsave(filename="./Models/LCM/graphs/text/m7F_2.png", plot=p, width =5 , height =4) # uncomment to produce graph in lines below the function
return( p )
}
# BuildLine("m2_R2")
# BuildLine("m1_R1")
# BuildLine("m0_R1")
# BuildLine("m1_F")
# BuildLine("m0_F")
BuildLine("m2_R2")
BuildLine("m1_R1")
