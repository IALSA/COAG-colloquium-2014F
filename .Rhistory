age, attend, timec,timec2,timec3 )  # Time Variant variables
head(ds)
table(ds$byear) # the year of birth  - metric: YEAR
table(ds$age) # years past 16 -  metric: AGE
table(ds$year, ds$age) # YEAR by  AGE
length(unique(ds$id)) # total No. of respondents in dataset
sum(!is.na(ds$attend)) # valid datapoints
sum(is.na(ds$attend)) # NA in the dataset
length(unique(ds$timec))
## FOR TESTING ###
# flmer<- as.formula(call_m2_R2)
# model <-lmer (flmer, data = ds, REML=FALSE,
#               control=lmerControl(optCtrl=list(maxfun=20000)))
# modelR<-model
#
# fnlme<- as.formula(call_m2_R2)
# model<- nlme::gls(fnlme, data=ds,method = "ML")
# modelF<-model
###################
allModels<- modelNamesLabels  # default definition of what models sequence contains
# modelList1<- c(modelsR1, modelsFE)
# modelList1<- c(modelsR2, modelsR3, modelsR4)
# allModels <-  "m0F"
# allModels <-  "m1F"
# allModels <-  "m0R1"
# allModels <-  "mFa"
# allModels <-  "mR1a"
# allModels <-   'm2_R2'
fixedOnly <- modelsFE
modelName<-  "m0_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
model
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
dsp<- data.frame(getME(model,"X")) # get the model frame
dsp
View(dsp)
modelName<-  "m1_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsp)
call_m0_R1 <- "attend ~ 1 + (1 | id) "
modelName<-  "m1_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsL)
View(dsp)
modelName<-  "m0_R1"
#   modelName<-  i  # should be "i" if not a specific model
message("Running model ", modelName, " in model-ESTIMATION.R at ", Sys.time())
modelCall<- paste0("call_",modelName)
f<- as.formula(modelCall)
model <- lme4::lmer (f, data = ds, REML=FALSE, control=lmerControl(optCtrl=list(maxfun=20000)))
###########################
# @knitr solveModel_lmer
## mInfo ##
# model<- modelR
mInfo<-summary(model)$AICtab
mInfo["N"]<- model@devcomp$dims["N"] # number of datapoints, verify
mInfo["p"]<- model@devcomp$dims["p"] # number of estimated parameters, verify
mInfo["ids"]<- (summary(model))$ngrps # number of units on level-2, here: individuals
# mInfo<- c(mInfo, "modelName"=modelName)
dsmInfo<-data.frame(mInfo)
dsmInfo<- plyr::rename(dsmInfo,replace= c("mInfo"=modelName))
dsmInfo$Coefficient <- rownames(dsmInfo)
dsmInfo # model information
## dsFERE ##
# model<- modelR
FE<- fixef(model) # summary of fixed effects
FEt<- summary(model)$coefficients # estimates of Fixed Effects, SE, t-value
mFE<- (summary(model)$vcov@factors$correlation) # matrix of correlations among Fixed Effects
mRE<-   data.frame(sd= (attr(summary(model)$varcor$id,"stddev")))
mRE$var<- mRE$sd^2
mRE<-mRE[c("var","sd")] # variances and standard deviations of random effects
mREcov<-  data.frame(     summary(model)$varcor$id   ) # covariance matrix of RE
mREcor<-  data.frame(attr(summary(model)$varcor$id,"correlation")) # corrleation matrix of RE
sigma<- sigma(model) # standard deviation of residual
a<- data.frame(FEt)
a$Coefficient <- rownames(a)
a<- plyr::rename(a,replace= c("Std..Error"="Std.Error"))
rowCountBeforeJoin <- nrow(a)
mFE<- (summary(model)$vcov@factors$correlation)
b<- as.data.frame(matrix(mFE@x, ncol=length(mFE@Dimnames[[1]]), byrow=TRUE, dimnames=mFE@Dimnames))
b$Coefficient <- rownames(b)
dsRE <- mRE
dsRE <- plyr::rename(dsRE, replace=c("var"="varRE", "sd"="sdRE"))
dsRE$Coefficient <- rownames(dsRE)
dsRECov <- mREcov
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECov <- plyr::rename(dsRECov, replace=c("X.Intercept."="intVarRE", "timec"="timecVarRE","timec2"="timec2VarRE","timec3"="timec3VarRE"),warn_missing = FALSE)
dsRECov$Coefficient <- rownames(dsRECov)
dsRECor <- mREcor
## - change here: if variables do not exist, create them anyway and populate with zeros
dsRECor <- plyr::rename(dsRECor, replace=c("X.Intercept."="intSDRE", "timec"="timecSDRE", "timec2"="timec2SDRE", "timec3"="timec3SDRE"),warn_missing = FALSE)
dsRECor$Coefficient <- rownames(dsRECor)
dsFERE <- merge(x=a, y=b, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRE, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECov, by="Coefficient", all=TRUE)
dsFERE <- merge(x=dsFERE, y=dsRECor, by="Coefficient", all=TRUE)
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<- modelName
testit::assert("The join shouldn't add new records.",  rowCountBeforeJoin==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(a))
testit::assert("The join shouldn't add new records.",  nrow(dsFERE)==nrow(b))
dsFERE$sigma<- sigma # residual SD, must be squared to get sigma squared
# dsFERE$modelName<-modelName
head(dsFERE)
## dsp ## - deconstructing predictions
# model<- modelR
dsp<- data.frame(getME(model,"X"))
View(dsp)
getME(model,"X")
str(model)
getME(model,"Intercetp.X")
BuildLine("m2_R2")
# rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run. This is not called by knitr, because it's above the first chunk.
require(ggplot2)
require(dplyr)
require(reshape2)
BuildLine <- function( modelName, baseSize=11 ) {
modelName<- "m1_R1"
# Traditional reading in the files
pathdsp  <- file.path("./Reports/LCMsequence/models/datasets", paste0(modelName,"_dsp.rds"))
dsp <- readRDS(pathdsp)
###############################################
### graph of prediction
# bgColour<-gray(.95)   # background color
indLineSz <-.08        # individual line size
#   indLineSz <-.5        # individual line size
indLineAl <-.06        # individual line alpha
#   indLineAl <-1        # individual line alpha
themeLine <- ggplot2::theme_bw(base_size=baseSize) +
ggplot2::theme(title=ggplot2::element_text(colour="gray20",size = 12)) +
ggplot2::theme(axis.text=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(axis.title=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(panel.border = ggplot2::element_rect(colour="gray80")) +
ggplot2::theme(axis.ticks.length = grid::unit(0, "cm")) +
ggplot2::theme(text = element_text(size =20)) #+
# ggplot2::theme(panel.background=element_rect(fill=bgColour,colour=NA)) +
# ggplot2::theme(legend.position=c(.95,.90),legend.direction="vertical") +
# ggplot2::theme(legend.background = element_rect(fill=NA)) +
# ggplot2::theme(legend.text = element_text(size = 15),legend.title.align =(-3.3))# +
# ggplot2::theme(panel.grid = element_line(linetype = 1,size=rel(3)))
ds<- dsp %>% dplyr::filter(id %in% c(1:9022))
# ds<- dsp
# head(ds)
p<- ggplot2::ggplot(ds, aes(x=timec, y=attend, group=id))
# geoms
p <- p + geom_line(aes(x=timec,y=yHat),colour="red",alpha=indLineAl,size=indLineSz, na.rm=T)
p <- p + geom_line(aes(y=yFE), fill=NA, na.rm=T)
# scales & coordinates
p <- p + scale_x_continuous(breaks=c(0:11))
p <- p + scale_y_continuous(breaks=seq(0, 8, 1))
p <- p + coord_cartesian(xlim=c(-.5, 11.5), ylim=c(.5, 8.5))
# themes, guide, and annotations
p <- p + themeLine
p <- p + labs(title="How often have you attended a worship service?", x="Years Since 2000", y="Church Attendance")
#   ggsave(filename="./Models/LCM/graphs/text/m7F_2.png", plot=p, width =5 , height =4) # uncomment to produce graph in lines below the function
return( p )
}
BuildLine("m2_R2")
BuildLine("m1_R1")
BuildLine("m2_R2")
BuildLine("m1_R1")
BuildLine("m2_R2")
BuildLine("m0_R1")
# rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run. This is not called by knitr, because it's above the first chunk.
require(ggplot2)
require(dplyr)
require(reshape2)
BuildLine <- function( modelName, baseSize=11 ) {
#   modelName<- "m1_R1"
# Traditional reading in the files
pathdsp  <- file.path("./Reports/LCMsequence/models/datasets", paste0(modelName,"_dsp.rds"))
dsp <- readRDS(pathdsp)
###############################################
### graph of prediction
# bgColour<-gray(.95)   # background color
indLineSz <-.08        # individual line size
#   indLineSz <-.5        # individual line size
indLineAl <-.06        # individual line alpha
#   indLineAl <-1        # individual line alpha
themeLine <- ggplot2::theme_bw(base_size=baseSize) +
ggplot2::theme(title=ggplot2::element_text(colour="gray20",size = 12)) +
ggplot2::theme(axis.text=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(axis.title=ggplot2::element_text(colour="gray40")) +
ggplot2::theme(panel.border = ggplot2::element_rect(colour="gray80")) +
ggplot2::theme(axis.ticks.length = grid::unit(0, "cm")) +
ggplot2::theme(text = element_text(size =20)) #+
# ggplot2::theme(panel.background=element_rect(fill=bgColour,colour=NA)) +
# ggplot2::theme(legend.position=c(.95,.90),legend.direction="vertical") +
# ggplot2::theme(legend.background = element_rect(fill=NA)) +
# ggplot2::theme(legend.text = element_text(size = 15),legend.title.align =(-3.3))# +
# ggplot2::theme(panel.grid = element_line(linetype = 1,size=rel(3)))
ds<- dsp %>% dplyr::filter(id %in% c(1:9022))
# ds<- dsp
# head(ds)
p<- ggplot2::ggplot(ds, aes(x=timec, y=attend, group=id))
# geoms
p <- p + geom_line(aes(x=timec,y=yHat),colour="red",alpha=indLineAl,size=indLineSz, na.rm=T)
p <- p + geom_line(aes(y=yFE), fill=NA, na.rm=T)
# scales & coordinates
p <- p + scale_x_continuous(breaks=c(0:11))
p <- p + scale_y_continuous(breaks=seq(0, 8, 1))
p <- p + coord_cartesian(xlim=c(-.5, 11.5), ylim=c(.5, 8.5))
# themes, guide, and annotations
p <- p + themeLine
p <- p + labs(title="How often have you attended a worship service?", x="Years Since 2000", y="Church Attendance")
#   ggsave(filename="./Models/LCM/graphs/text/m7F_2.png", plot=p, width =5 , height =4) # uncomment to produce graph in lines below the function
return( p )
}
# BuildLine("m2_R2")
# BuildLine("m1_R1")
# BuildLine("m0_R1")
# BuildLine("m1_F")
# BuildLine("m0_F")
BuildLine("m2_R2")
BuildLine("m1_R1")
install.packages('Rd2roxygen')
library(Rd2roxygen)
rab('animation', install = TRUE)
library(Rd2roxygen)
rab('animation', install = TRUE)
?animation
??animation
# Clear memory from previous runs
base::rm(list=base::ls(all=TRUE))
## @knitr LoadPackages
# Load the necessary packages.
base::require(base)
base::require(knitr)
base::require(markdown)
base::require(testit)
base::require(dplyr)
base::require(reshape2)
base::require(stringr)
base::require(stats)
base::require(ggplot2)
## @knitr DeclareGlobals
## @knitr LoadData
# Link to the data source
myExtract <- "./Data/Extract/NLSY97_Attend_20141021/NLSY97_Attend_20141021"
pathSourceData <- paste0(myExtract,".csv")
SourceData <- read.csv(pathSourceData,header=TRUE, skip=0,sep=",")
ds0 <- SourceData
## @knitr ImportVarLabels
### NLSY97 variable "id" is linked to the descriptive label in the header of the STATA formated data file.dtc" ###
pathSourceLabels <- paste0(myExtract,".dct")
SourceLabels<-read.csv(pathSourceLabels,header=TRUE, skip=0,nrow=17, sep="")
SourceLabels$X.<-NULL # remove extra column
SourceLabels
# rename columns to match NLS Web Investigator format
SourceLabels<-plyr::rename(SourceLabels,
replace=c("infile"="RNUM","dictionary"="VARIABLE_TITLE")
)
# sort for visual inspection
SourceLabels<-SourceLabels[ with(SourceLabels, order(RNUM)), ]
SourceLabels
## @knitr RenameVariables
# rename variables for easier handling
ds0<-plyr::rename(ds0,
c("R0000100"="id",
"R0536300"="sex",
"R1482600"="race",
"R0536402"="byear",
"R0536401"="bmonth",
"R4893400"="attend_2000",
"R6520100"="attend_2001",
"S0919300"="attend_2002",
"S2987800"="attend_2003",
"S4681700"="attend_2004",
"S6316700"="attend_2005",
"S8331500"="attend_2006",
"T0739400"="attend_2007",
"T2781700"="attend_2008",
"T4495000"="attend_2009",
"T6143400"="attend_2010",
"T7637300"="attend_2011"
)
)
## @knitr QueryData1
# with $
a <- ds0$id # extracts column "id" from dataset "ds0"
class(a)
str(a)
## @knitr QueryData2
# with [ ]
a <- ds0[,c("id","sex")] # extracts column "id" from dataset "ds0"
class(a)
str(a)
## @knitr QueryData3
# with dplyr package
require(dplyr)
filter(ds0, id<5) %>% select(id,sex, race)
## @knitr arrivedsW
# Manually create the vector that contains the names of the variables you would like to keep.
attend_years <- paste0("attend_",c(2000:2011))
selectVars <- c("id", "sex", "race", "byear", "bmonth", attend_years)
dsW <- ds0[,selectVars]
## @knitr RemoveIllegal
# Remove illegal values. See codebook for description of missingness
illegal<-as.integer(c(-5:-1,997,998,999))
for( variable in names(dsW) ){
dsW[,variable]=ifelse(dsW[,variable] %in% illegal,NA,dsW[,variable])
}
# Include only records with a valid birth year
dsW <- dsW[dsW$byear %in% 1980:1984, ]
#Include only records with a valid ID
dsW <- dsW[dsW$id != "V", ] # rows that do NOT(!) equal string 'V"
dsW$id <- as.integer(dsW$id) # forced to be integer
rm(list=setdiff(ls(), c("ds0","dsW")))
# cat("\014") # clears console
# str(dsW)
## @knitr Melt01
require(dplyr)
dplyr::filter(dsW, id < 5)
## @knitr Melt02
TIvars<-c("id", "sex","race", "bmonth","byear") # Time Invariant (TI)
# id.vars tells what variables SHOULD NOT be stacked
dsLong <- reshape2::melt(dsW, id.vars=TIvars) # melt
dplyr::filter(dsLong, id == 1)
## @knitr Melt03
# nrow(dsLong)/length(unique(dsLong$id)) # should be integer
dsLong <- dplyr::filter(dsLong,!is.na(id)) # remove obs with invalid id
# nrow(dsLong)/length(unique(dsLong$id)) # verify that melting is fine
# dplyr::filter(dsLong,id==1) # inspect
## @knitr Melt04
# create varaible "year" by stripping the automatic ending in TV variables' names
# subset 4 characters from the end of the string a into new variable
dsLong$year<-str_sub(dsLong$variable,-4,-1)
dplyr::filter(dsLong, id == 1)
## @knitr Melt05
# remove the automatic ending
removePattern <- paste0("_",c(2000:2011))
for (i in removePattern){
dsLong$variable <- gsub(pattern=i, replacement="", x=dsLong$variable)
}
dsLong$year <- as.integer(dsLong$year) # Convert to a number.
dplyr::filter(dsLong,id==1) # inspect
table(dsLong$variable)
